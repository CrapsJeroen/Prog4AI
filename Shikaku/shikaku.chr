:- use_module(library(chr)).
:- use_module(library(lists)).
:- [puzzles].
:- chr_constraint rect/5, rect_temp/5, makeDomains/3, dom/2.



solve(Name) <=> puzzle(Name,Width,Height,Ps), dom(Width,Height), makeDomains(Ps).


makeDomains(_,_,[]) <=> true.
dom(W,H) \ makeDomains([(I,J,V)|Ps]) <=>
  X1 is I-W, X2 is I,
  Y1 is J-H, Y2 is J
  | fromTo(X1,X2,LX), fromTo(W,W+V,T), subtract(LX,T,Xs),
    fromTo(Y1,Y2,LY), fromTo(H,H+V,T), subtract(LY,T,Ys),
    generateSizes(V,Ss), rect_temp(I,J,Xs,Ys,Ss), makeDomains(Width,Height,Ps).

%FAILURE
failureX @ rect_temp(_,_,[],_,_) <=> fail.
failureY @ rect_temp(_,_,_,[],_) <=> fail.
failureS @ rect_temp(_,_,_,_,[]) <=> fail.

%Contains no other points
above @ point(I,J,_) \ rect_temp(I2,J,Xs,Ys,Ss) <=> I < I2, upTo(I,L), subtract(Xs,L,NL), Xs \== NL | rect_temp(I2,J,NL,Ys,Ss).
left @  point(I,J,_) \ rect_temp(I,J2,Xs,Ys,Ss) <=> J < J2, upTo(J,L), subtract(Ys,L,NL), Ys \== NL | rect_temp(I,J2,NL,Ys,Ss).

%Finalise rectangle
onlyOption @ rect_temp(I,J,[X],[Y],[S]) <=> rect(c(I,J),c(X,Y),S).



%Deleting values outside
/*
outsideBoardX @ dom(W,_), point(I,J,V) \ rect_temp(I,J,Xs,Ys,Ss) <=>
  fromTo(W,W+V,T), subtract(Xs,T,L), Xs \== L | rect_temp(I,J,L,Ys,Ss).
outsideBoardY @ dom(_,H), point(I,J,V) \ rect_temp(I,J,Xs,Ys,Ss) <=>
  fromTo(H,H+V,T), subtract(Ys,T,L), Ys \== L | rect_temp(I,J,Xs,L,Ss).
*/

outsideDom @ domain(Width,Height) \ rect(I,J,X,Y,W,H) <=> X2 is X+W, Y2 is Y+H,
            X =< 0, Y =< 0,
            X > X2, Y > Y2 | true.

overlaps @ rect(_,_,XA,YA,WA,HA), rect(_,_,XB,YB,WB,HB) <=>
            XA2 is XA+WA-1, XB2 is XB+WB-1,
            YA2 is YA+HA-1, YB2 is YB+HB-1,
            XA < XB2, XA2 > XB,
            YA < YB2, YA2 > YB | fail.

generateSizes(V,Ss):-
  upTo(V,L),
  findall(s(W,H),(member(W,L),member(H,L), T is W*H, T == V),Ss).

upto(0,[]).
upto(N,[N|L]) :- N>0, N1 is N-1, upto(N1,L).

fromTo(N,N,[N]).
fromTo(M,N,[Tail]):-
  M =< 0,
  M1 is M+1,
  fromTo(M1,N,Tail).
fromTo(M,N,[M|Tail]):-
  M > 0,
  M1 is M+1,
  fromTo(M1,N,Tail).
