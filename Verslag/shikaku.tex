\section{Task 2: Shikaku}\label{sec:shikaku}
\subsection{Introduction}

A shikaku is a puzzle consisting of a recangular grid where some positions on the grid are filled by a number. The goal of the puzzle is to paritition the grid into rectangles where each rectangle contains exactly one number and its area is equal to the value of that number. This a a fairly easy task to do manually, but it quickly gets more complicated as the puzzle gets larger. We have attempted to find a source which calculated the computational complexity of Shikaku puzzles. Sadly, we could only find references to a single article\cite{Takenaga}. This article claims that Shikaku puzzles are NP-Complete, but since we could not find a way to get a hold of the actual article itself we cannot verify its validity. \\





\begin{figure}[h]
\centering
\begin{subfigure}{.5\textwidth}
  \centering
  {\setstretch{0.875}
\begin{alltt}
\begin{center}
\textSFi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFiii
\textSFxi 3   .   .   .   .   .   4 \textSFxi
\textSFxi                           \textSFxi
\textSFxi .   .   .   5   .   .   2 \textSFxi
\textSFxi                           \textSFxi
\textSFxi 2   2   .   .   3   .   . \textSFxi
\textSFxi                           \textSFxi
\textSFxi .   .   6   .   .   .   . \textSFxi
\textSFxi                           \textSFxi
\textSFxi .   .   .   5   .   .   3 \textSFxi
\textSFxi                           \textSFxi
\textSFxi .   .   3   2   .   2   . \textSFxi
\textSFxi                           \textSFxi
\textSFxi .   .   .   .   7   .   . \textSFxi
\textSFii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFiv
\end{center}
\end{alltt}
}
  \caption{The Shikaku puzzle...}
  \label{fig:shikaku1a}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
  \centering
  {\setstretch{0.875}
\begin{alltt}
\begin{center}
\textSFi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFiii
\textSFxi 3   .   . \textSFxi .   .   .   4 \textSFxi
\textSFviii\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFix
\textSFxi . \textSFxi .   .   5   .   . \textSFxi 2 \textSFxi
\textSFxi   \textSFviii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFix   \textSFxi
\textSFxi 2 \textSFxi 2   . \textSFxi .   3   . \textSFxi . \textSFxi
\textSFviii\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFv\textSFx\textSFx\textSFx\textSFix
\textSFxi .   .   6   .   .   . \textSFxi . \textSFxi
\textSFviii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFix   \textSFxi
\textSFxi .   .   .   5   . \textSFxi . \textSFxi 3 \textSFxi
\textSFviii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvi\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFix   \textSFxi   \textSFxi
\textSFxi .   .   3 \textSFxi 2   . \textSFxi 2 \textSFxi . \textSFxi
\textSFviii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFvii\textSFx\textSFx\textSFx\textSFix
\textSFxi .   .   .   .   7   .   . \textSFxi
\textSFii\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFx\textSFiv
\end{center}
\end{alltt}
}
  \caption{... and its solution}
  \label{fig:shikaku1b}
\end{subfigure}
\caption{An example of a 7 by 7 Shikaku puzzle}
\label{fig:shikaku1}
\end{figure}

\subsection{Terminology}
Because a Shikaku cannot easily be described as a matrix of values, we will introduce some terminology. To denote the value of number on the grid write $\upsilon(x,y)$, where $x$ denotes the column of the grid and $y$ denotes the row. Note that both coordinates start at $1$. For instance: $\upsilon(1,1) = 3$ and $\upsilon(4,2) = 5$ in the Shikaku shown in figure~\ref{fig:shikaku1}. 
\\
The field itself has certain dimensions. All dimensions are denoted as a pair $s(w,h)$, where $w$ is the width (the amount of columns) and $h$ is the height (the amount of rows). In the running example, the dimensions of the field are $s(7,7)$. 
\\
To uniquely define a rectangle we need both a position on the grid ( the top left corner) and a size. Positions are denoted in a similar way as sizes: $c(x,y)$ represents the grid position shared by column $x$ and row $y$. With this, we can define a rectangle like this: $rect(c(i,j),c(x,y),s(w,h))$. Here is $c(i,j)$ the number contained within the rectangle, $c(x,y)$ the top-left position of the rectangle and $s(w,h)$ the dimensions of the rectangle. We have decided to also put the position of the value contained by the rectangle in its definition to make the notation more analogous to our implemented code. As an example: $rect(c(7,1),c(4,1),s(4,1))$ is the rectangle in the top right corner of the solved puzzle in figure~\ref{fig:shikaku1b} 
\\
While the following concept seem obvious from the drawings of the game, we will still include their formal definitions for the sake of completeness. The first important concept is $contains(c(x,y), s(w,h),c(i,j))$. This implies that the grid position $c(i,j)$ lies inside the boundary of the rectangle $rect(p,c(x,y),s(w,h))$.
\begin{equation}
contains(c(x,y), s(w,h),c(i,j)) \iff i \in [x,x+w-1] \wedge j \in [y,y+h-1]
\end{equation}
Another important concept is when two rectangles overlap. Two rectangles overlap when they share at least 1 grid position. It is expressed as $overlap(c(x_a,y_a), s(w_a,h_a),c(x_b,y_b), s(w_b,h_b))$. This means that $rect(p_a, c(x_a,y_a), s(w_a,h_a))$ and $rect(p_b,c(x_b,y_b), s(w_b,h_b))$.
\begin{equation}
\begin{split}
overlap(c(x_a,y_a), s(w_a,h_a),c(x_b,y_b), s(w_b,h_b)) \iff x_a \leq x_b + w_b -1 \wedge x_b \leq x_a + w_a - 1  \\
									   \wedge \: y_a \leq y_b + h_b -1 \wedge y_b \leq y_a + h_a - 1 
\end{split}
\end{equation}

\subsection{Shikaku in ECLiPSe}
For our ECLiPSe Shikaku representation we use make heavy use of libraries provided by the platform. We use the rect structure provided by the gfd library to represent the rectangles.

\subsection{Shikaku in CHR}
\subsubsection{Problem representation}
The CHR implementation of our Shikaku solver makes less use of libraries than our ECLiPSe implementation. The first step is generating what we call temporary rectangles. These are rectangles which have not yet been defined fully defined. The goal of the solver is to fully define all these temporary rectangles while respecting the given constraints. This is the solution for the puzzle. The temporary rectangles consist of a grid locations corresponding to the location of the value it contains, and a list of tuples containing a grid location and dimensions each. Each tuple represents a possible top left corner of the rectangle and its size. 
\\ \\
Many of the constraints can be checked without having to know about other rectangles. This makes it possible to completely apply these constraints without any backtracking at all. We do this by checking against these constraints when generating the list of tuples for each temporary rectangle. The constraints taken into account when generating the domain of possible rectangles in the first place are: Each rectangle needs to have an area equal to the value it contains, each rectangle needs to actually contain the value it claims to contain in its definition, and each rectangle needs to fully fit within the field. Because these constraints are applied proactively, they are active constraints.

\subsubsection{Solver outline}
In the code below,  \texttt{makeDomains} iteratively calls \texttt{generateOptions} for each of the values on the grid. With the resulting list of options, a \texttt{rectTemp} CHR constraint is generated. \texttt{generateOptions} collects all the possible options generated by \texttt{generateSingleOption} and returns them as a list. \texttt{generateSingleOption} contains the constraints described above and will return all possible solutions satisfying those constraints one by one. 

\begin{lstlisting}
makeDomains([],_) <=> true.
makeDomains([(X,Y,Value)|Points],FieldSize) <=>
	generateOptions(c(X,Y),Value,FieldSize,OptionsList),
	rectTemp(c(X,Y),OptionsList),
	makeDomains(Points,FieldSize).
	
generateOptions(Pos,Value,FieldSize,OptionsList):-
    findall(Option,
		generateSingleOption(Pos,Value,FieldSize,Option),
		OptionsList)
		
generateSingleOption(Point,Value,FieldSize,(Pos,Size)):-
	correctSize(Size,Value),
	contains(Pos,Size,Point),
	inField(Pos,Size,FieldSize).
\end{lstlisting}

Once all these temporary rectangles are generated, only one more constraint needs to be checked: Rectangles may not overlap eachother.

\begin{lstlisting}
rect(_,Pos,Size) \ rectTemp(Point,OptionsList) <=>
	removeRectOverlap(Pos,Size,OptionsList,NewList),
	OptionsList \== NewList
	| rectTemp(Point,NewList).
	
failure @ rectTemp(_,[]) <=> fail.

\end{lstlisting}


This constraint removes all overlapping options from the list of options of every temporary rectangle. If it some point there is a temporary rectangle with no options left, the search will backtrack. This constraint is also an active constraint because it proactively limits the domains of all other temporary rectangles as soon as a permanent rectangle is added.
\begin{lstlisting}
search, rectTemp(Point,OptionsList) <=>
	try_option(Point,OptionsList),
	search.
search <=> true.

try_option(_,[]) :- fail.
try_option(Point,[(Pos,Size)|Options]):-
    rect(Point,Pos,Size)
    ;
    try_option(Point,Options).
\end{lstlisting}

The search is very simple. It picks a temporary rectangle and tries every option in its list of options. This is done by constructing a permanent rectangle from the option and checking whether or not that leads to a failure. If a failure is found, backtracking happens and the next option is tried. In case not a single option succeeds, another failure is caused which will backtrack the search to its previous decision. Once a permanent rectangle is found that does not lead to a failure, the search starts over again with the next temporary rectangle.

\subsubsection{Additional optimizations}

One additional constraint we came up with is ensuring that only a single value is contained within each rectangle. This constraint is already provided by the combination of having each rectangle contain the value in its definition and not allowing rectangles to overlap. The critical part here is that the solver can decide whether ot not a rectangle contains other values without the need to know about other rectangles. This observation allows the solver to limit the domains of each temporary rectangle even more before and prevents a large amount of backtracks. The way we implemented this is very similar to how the overlap between rectangles is handled. Since this is constraint proactively limits the search domain, it is also an active constraint.

\begin{lstlisting}
rectTemp(RefPoint,_) \ rectTemp(Point,OptionsList) <=>
	removePointOverlap(RefPoint,OptionsList,NewList),
	OptionsList \== NewList
	| rectTemp(Point,NewList).
\end{lstlisting}

--- TABEL MET VERSCHIL--- \\ \\

Our second optimization is not a constraint, but instead it is a smarter search heuristic.Our first approach to searching did not define an order in which the temporary rectangles should be searched. During testing we observed that a small rectangle (for instance size 2) placed the wrong way early into the search process could make the solver take a really long time trying to fit all the other rectangles. The solver would often fail really deep into the search and have to backtrack all the way to the start. \\
 Another observation was the fact that the really large rectangles in the larger puzzles only had relatively few options compared to their size thanks to our previous optimization. Most options would get filtered out right away because they would contain other values. These large rectangles also had a very large effect on the domains of other temporary rectangles. A rectangle of size 2 can only affect at least one temporary rectangle, but a rectangle of size 30 or higher will have many neighbors. Our reasoning was that by trying to place the large rectangles first, the solver could significantly reduce the search domain going forward and limit the depth at which backtracking usually occurs.
 \begin{lstlisting}
 search(N), rectTemp(Point,OptionsList) <=>
	member((_,s(Width,Height)),OptionsList),
	Width*Height >= N
	| try_option(Point,OptionsList),
	search(N).
search(0) <=> true.
search(N) <=> N1 is N - 1, search(N1).
\end{lstlisting}
The search constraint should be initialized with a value at least as large as the largest possible rectangle. For simiplicity we simply initialize it with the total area of the grid, but looking for the highest value on the grid will also work. In each search step, it will try to place rectangles of at least the current value. If no temporary rectangles of sufficient size are matched, the value for the search is decremented repeatedly until the next match. \\

--- TABEL MET VERSCHIL--- \\ \\
\subsection{Conclusions}


